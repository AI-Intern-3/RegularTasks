To create an output file with the same name as the input file but with the current date and time appended, you can extract the filename from the input file path, append the date and time, and then save it accordingly. Here's the script with that modification:

```python
import pandas as pd
import requests
from datetime import datetime
from openpyxl import load_workbook
from openpyxl.styles import PatternFill
import os

# Define file path
input_file_path = r"C:\Users\Sparx\Desktop\Trillixent Technologies\Automation for Website\new.xlsx"

# Function to check if a URL is reachable and return the status code
def check_url(url):
    try:
        response = requests.get(url, timeout=10)
        return response.status_code
    except requests.RequestException as e:
        return f"Error: {e}"

# Load the Excel file
df = pd.read_excel(input_file_path)

# Initialize lists to store results
https_statuses = []
http_statuses = []
http_working = []

# Iterate over the rows of the DataFrame
for index, row in df.iterrows():
    domain = str(row['Domain Name'])  # Convert domain to string
    if domain.startswith('https://'):
        https_url = domain
        http_url = domain.replace('https://', 'http://')
    else:
        https_url = f'https://{domain}'
        http_url = f'http://{domain}'

    # Check https
    https_status = check_url(https_url)
    http_status = check_url(http_url)

    # Append results to lists
    https_statuses.append(https_status)
    http_statuses.append(http_status)
    http_working.append('Yes' if 'Error' not in str(http_status) else 'No')

# Add new columns to the DataFrame
df['https Status'] = https_statuses
df['http Status'] = http_statuses
df['http Working'] = http_working

# Extract original file name without extension and directory
original_file_name = os.path.splitext(os.path.basename(input_file_path))[0]

# Generate new filename with current date and time appended
current_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
output_file_name = f"{original_file_name}_{current_time}.xlsx"
output_file_path = os.path.join(os.path.dirname(input_file_path), output_file_name)

# Save the updated DataFrame to a new Excel file
df.to_excel(output_file_path, index=False)

# Apply coloring to the columns using openpyxl
wb = load_workbook(output_file_path)
ws = wb.active

# Define the colors
faint_orange = PatternFill(start_color="FFDAB9", end_color="FFDAB9", fill_type="solid")  # Faint Orange
faint_green = PatternFill(start_color="98FB98", end_color="98FB98", fill_type="solid")  # Faint Green

# Apply color to old columns
for col in ws.iter_cols(min_col=1, max_col=len(df.columns)-3, min_row=2, max_row=ws.max_row):
    for cell in col:
        cell.fill = faint_orange

# Apply color to new columns
for col in ws.iter_cols(min_col=len(df.columns)-2, max_col=ws.max_column, min_row=2, max_row=ws.max_row):
    for cell in col:
        cell.fill = faint_green

# Save the workbook
wb.save(output_file_path)

print(f"Report with colors saved to {output_file_path}")
```

### Explanation:
1. **Extracting Filename**: 
   - `os.path.splitext(os.path.basename(input_file_path))[0]` is used to get the base name of the file without the extension.
2. **Appending Date and Time**:
   - The `current_time` variable is formatted as `"%Y-%m-%d_%H-%M-%S"`.
   - The new filename is generated by appending the date and time to the original filename.
3. **Saving the File**:
   - The new file is saved in the same directory as the original file with the updated name.
   
This script ensures that the output file is named after the original file with the current date and time, making it easily identifiable and preserving the original file intact.
